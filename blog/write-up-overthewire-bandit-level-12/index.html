<!doctype html><html lang=en>
<head>
<title>
Write-up: OverTheWire - Bandit Level 12 → level 13 | Justin Perdok
</title>
<meta name=title content="Write-up: OverTheWire - Bandit Level 12 → level 13 | Justin Perdok">
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="chrome=1">
<meta name=HandheldFriendly content="True">
<meta name=MobileOptimized content="320">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=referrer content="no-referrer-when-downgrade">
<base href=https://justin-p.me/>
<meta name=description content="IT Geek, Ethical Hacker, DevOps Nut, PowerShell Fanatic and lover of beers🍻">
<meta name=author content="Justin Perdok">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:site content="@JustinPerdok">
<meta name=twitter:creator content="@JustinPerdok">
<meta property="og:title" content="Write-up: OverTheWire - Bandit Level 12 → level 13 | Justin Perdok">
<meta property="og:type" content="website">
<meta property="og:url" content="https://justin-p.me/">
<meta property="og:image" content="https://justin-p.me//images/osprey.png">
<meta property="og:description" content="IT Geek, Ethical Hacker, DevOps Nut, PowerShell Fanatic and lover of beers🍻">
<link rel=icon type=image/png sizes=16x16 href=favicon.ico>
<meta name=theme-color content="#FFF">
<link rel=canonical href=https://justin-p.me/blog/write-up-overthewire-bandit-level-12/>
<link rel=stylesheet href=https://justin-p.me/style.3d9ed0c8ed4a7de59d1a99f6c56fa9ab43daaa5b8951f2082b11faa9417532b8.css type=text/css>
<style>.lazyload{opacity:.0001}.logo .lazyload{min-width:10em}</style>
<script src=https://justin-p.me/js/vendor/lazysizes.min.js async></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css>
</head>
<body>
<nav class="row middle-xs center-xs">
<div class="col-xs-6 col-sm-1 logo">
<a href=https://justin-p.me/#><img data-src=https://justin-p.me/images/me.png class=lazyload lazyload=on alt="Justin Perdok"></a>
</div>
<div class="col-xs-3 col-sm-2">
<h3><a href=https://justin-p.me/#about>About</a></h3>
</div>
<div class="col-xs-3 col-sm-2">
<h3><a href=https://justin-p.me/#work>Work</a></h3>
</div>
<div class="col-xs-3 col-sm-2">
<h3><a href=https://justin-p.me/#blog>Blog</a></h3>
</div>
<div class="col-xs-6 col-sm-1 nav-toggle">
<a href class=nav-icon onclick=return!1>
<img data-src=https://justin-p.me/images/icon-menu.png class=lazyload lazyload=on alt="Open Menu">
<img data-src=https://justin-p.me/images/icon-x.png class=lazyload lazyload=on alt="Close Menu" style=display:none>
</a>
</div>
</nav>
<section class="nav-full row middle-xs center-xs">
<div class=col-xs-12>
<div class="row middle-xs center-xs">
<div class=col-xs-12><h1><a href=https://justin-p.me/#about>About</a></h1></div>
<div class=col-xs-12><h1><a href=https://justin-p.me/#work>Work</a></h1></div>
<div class=col-xs-12><h1><a href=https://justin-p.me/#blog>Blog</a></h1></div>
</div>
</div>
</section>
<main>
<section class=container>
<section class=content>
<h1> Write-up: OverTheWire - Bandit Level 12 → level 13 </h1>
<div class=sub-header>
September 11, 2019 · 10 minutes read
</div>
<article class=entry-content>
<h3 id=bandit-level-12--level-13>Bandit Level 12 → Level 13</h3>
<p><strong>Level Goal:</strong>
<em>The password for the next level is stored in the file data.txt, which is a hexdump of a file that has been repeatedly compressed. For this level it may be useful to create a directory under /tmp in which you can work using mkdir. For example: mkdir /tmp/myname123. Then copy the datafile using cp, and rename it using mv (read the manpages!)</em></p>
<p>So lets see what we have. As the goal explained a data.txt which is a hexdump of compressed data.</p>
<pre tabindex=0><code>~/wargames/overthewire/bandit$ ssh bandit12@bandit.labs.overthewire.org -p 2220

bandit12@bandit~$ ls -la
total 24
drwxr-xr-x  2 root     root     4096 Oct 16  2018 .
drwxr-xr-x 41 root     root     4096 Oct 16  2018 ..
-rw-r--r--  1 root     root      220 May 15  2017 .bash_logout
-rw-r--r--  1 root     root     3526 May 15  2017 .bashrc
-rw-r-----  1 bandit13 bandit12 2581 Oct 16  2018 data.txt
-rw-r--r--  1 root     root      675 May 15  2017 .profile
bandit12@bandit~$ cat data.txt
00000000: 1f8b 0808 d7d2 c55b 0203 6461 7461 322e  .......[..data2.
00000010: 6269 6e00 013c 02c3 fd42 5a68 3931 4159  bin..&lt;...BZh91AY
00000020: 2653 591d aae5 9800 001b ffff de7f 7fff  &amp;amp;SY.............
00000030: bfb7 dfcf 9fff febf f5ad efbf bbdf 7fdb  ................
00000040: f2fd ffdf effa 7fff fbd7 bdff b001 398c  ..............9.
00000050: 1006 8000 0000 0d06 9900 0000 6834 000d  ............h4..
00000060: 01a1 a000 007a 8000 0d00 0006 9a00 d034  .....z.........4
00000070: 0d1a 3234 68d1 e536 a6d4 4000 341a 6200  ..24h..6..@.4.b.
00000080: 0069 a000 0000 0000 d003 d200 681a 0d00  .i..........h...
00000090: 0001 b51a 1a0c 201e a000 6d46 8068 069a  ...... ...mF.h..
000000a0: 6834 340c a7a8 3406 4000 0680 0001 ea06  h44...4.@.......
000000b0: 8190 03f5 4032 1a00 0343 4068 0000 0686  ....@2...C@h....
000000c0: 8000 0320 00d0 0d00 0610 0014 1844 0308  ... .........D..
000000d0: 04e1 c542 9ab8 2c30 f1be 0b93 763b fb13  ...B..,0....v;..
000000e0: 50c4 c101 e008 3b7a 92a7 9eba 8a73 8d21  P.....;z.....s.!
000000f0: 9219 9c17 052b fb66 a2c2 fccc 9719 b330  .....+.f.......0
00000100: 6068 8c65 e504 5ec0 ae02 fa6d 16bc 904b  `h.e..^....m...K
00000110: ba6c f692 356e c02b 0374 c394 6859 f5bb  .l..5n.+.t..hY..
00000120: 0f9f 528e 4272 22bb 103c 2848 d8aa 2409  ..R.Br&quot;..&lt;(H..$.
00000130: 24d0 d4c8 4b42 7388 ce25 6c1a 7ec1 5f17  $...KBs..%l.~._.
00000140: cc18 ddbf edc1 e3a4 67f1 7a4d 8277 c823  ........g.zM.w.#
00000150: 0450 2232 40e0 07f1 ca16 c6d6 ef0d ecc9  .P&quot;2@...........
00000160: 8bc0 5e2d 4b12 8586 088e 8ca0 e67d a55c  ..^-K........}.\
00000170: 2ca0 18c7 bfb7 7d45 9346 ea5f 2172 01e4  ,.....}E.F._!r..
00000180: 5598 673f 45af 69b7 a739 7814 8706 04ed  U.g?E.i..9x.....
00000190: 5442 1240 0796 6cc8 b2f6 1ef9 8d13 421d  TB.@..l.......B.
000001a0: 461f 2e68 4d91 5343 34b5 56e7 46d0 0a0a  F..hM.SC4.V.F...
000001b0: 72b7 d873 71d9 6f09 c326 402d dbc0 7cef  r..sq.o..&amp;amp;@-..|.
000001c0: 53b1 df60 9ec7 f318 00df 3907 2e85 d85b  S..`......9....[
000001d0: 6a1a e105 0207 c580 e31d 82d5 8646 183c  j............F.&lt;
000001e0: 6a04 4911 101a 5427 087c 1f94 47a2 270d  j.I...T'.|..G.'.
000001f0: ad12 fc5c 9ad2 5714 514f 34ba 701d fb69  ...\..W.QO4.p..i
00000200: 8eed 0183 e2a1 53ea 2300 26bb bd2f 13df  ......S.#.&amp;amp;../..
00000210: b703 08a3 2309 e43c 44bf 75d4 905e 5f96  ....#..&lt;D.u..^_.
00000220: 481b 362e e82d 9093 7741 740c e65b c7f1  H.6..-..wAt..[..
00000230: 5550 f247 9043 5097 d626 3a16 da32 c213  UP.G.CP..&amp;amp;:..2..
00000240: 2acd 298a 5c8a f0c1 b99f e2ee 48a7 0a12  *.).\.......H...
00000250: 03b5 5cb3 0037 cece 773c 0200 00         ..\..7..w&lt;...
</code></pre><p>Lets create a folder in /tmp/ where we can work and copy over this file.</p>
<pre tabindex=0><code>bandit12@bandit~$ mkdir /tmp/esc
bandit12@bandit~$ cd /tmp/esc
bandit12@bandit/tmp/esc$
bandit12@bandit/tmp/esc$ cp ~/data.txt data.hex
bandit12@bandit/tmp/esc$ ls
data.hex
</code></pre><p>First thing first, lets return this hexdump back to a file with <code>xxd</code>. <code>xxd</code> has a a revert flag <code>-r</code>. With this you can restore a hexdump back to its original binary form.</p>
<pre tabindex=0><code>bandit12@bandit/tmp/esc$ xxd -r data.hex &gt;&gt; reversedhex.out
</code></pre><p>Now lets check what this file is with the <code>file</code> command.</p>
<pre tabindex=0><code class=language-bandit12@bandit/tmp/esc$ data-lang=bandit12@bandit/tmp/esc$>reversedhex.out: gzip compressed data, was &quot;data2.bin&quot;, last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix
</code></pre><p>Okay its a <code>gzip</code> compressed file. We could use <code>gunzip</code> to decompress, but it tents to be iffy about file names, so lets use <code>zcat</code> instead. <code>zcat</code> will decompress files whether they have a .gz suffix or not.</p>
<pre tabindex=0><code>bandit12@bandit/tmp/esc$ zcat reversedhex.out &gt; zcat_out.1
bandit12@bandit/tmp/esc$ file zcat_out.1
zcat_out.1: bzip2 compressed data, block size = 900k
</code></pre><p>So now we have a bzip2 file. No problem lets use <code>bzip -d</code> . Then we get a <code>gzip</code> again, lets <code>zcat</code> again. Now we have a <code>tar</code> archive. And another <code>tar</code>.</p>
<pre tabindex=0><code>bandit12@bandit/tmp/esc$ bzip2 -d zcat_out.1
bzip2: Can't guess original name for zcat_out.1 -- using zcat_out.1.out
bandit12@bandit/tmp/esc$ file zcat_out.1.out
zcat_out.1.out: gzip compressed data, was &quot;data4.bin&quot;, last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix
bandit12@bandit/tmp/esc$ zcat zcat_out.1.out &gt; zcat_out.2
bandit12@bandit/tmp/esc$ file zcat_out.2
zcat_out.2: POSIX tar archive (GNU)
bandit12@bandit/tmp/esc$ tar xvf zcat_out.2
data5.bin
bandit12@bandit/tmp/esc$ file data5.bin
data5.bin: POSIX tar archive (GNU)
</code></pre><p>I&rsquo;m beginning to sense a pattern here. Let&rsquo;s stop doing this by hand and script it.</p>
<p>Lets create a file named <code>unpackhex.sh</code> and make it executable. Then copy over the original file to data.hex and reverse it back to a file, then open vim and create our script.</p>
<pre tabindex=0><code>bandit12@bandit/tmp/esc$ touch unpackhex.sh
bandit12@bandit/tmp/esc$ chmod +x unpackhex.sh
bandit12@bandit/tmp/esc$ cp ~/data.txt data.hex
bandit12@bandit/tmp/esc$ xxd -r data.hex &gt;&gt; reversed.hex
bandit12@bandit/tmp/esc$ vim unpackhex.sh
</code></pre><p>Lets start with a scaffold. We known we want some function to check what file type the current file is and some function that we call in a loop that will decompresses the files.</p>
<pre tabindex=0><code>#bin/bash
# function to get filetype using file and cut
function get_file_type () {
    # get file type
}
# function to match filetypes to correct command
function decompress () {
    # check file type
    # if statements to use correct decompress command
    # if filetype is ASCCI stop the loop.
}
LOOP=1
until [ $LOOP = 0 ]
do
        # call decompress function
done
</code></pre><p>For the <code>get_file_type</code> function we can use <code>file</code> and <code>cut</code>. We can use <code>cut</code> to remove sections from the line that <code>file</code> returns. If we look at the string that <code>file</code> returns we see that the file type is encased with spaces.</p>
<pre tabindex=0><code>reversedhex.out: gzip compressed data, was &quot;data2.bin&quot;, last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix
</code></pre><p>If we simply tell <code>cut</code> to use spaces as delimiters with the <code>-d</code> flag we should be good. We only need to select the correct field with the <code>-f</code> flag, which is <code>2</code>.</p>
<p>Our function now looks like this. Now lets focus on the decompression function.</p>
<pre tabindex=0><code>function get_file_type () {
        file $1 | cut -d &quot; &quot; -f 2
}
</code></pre><p>We first call the <code>get_file_type</code> function with the input ( <code>$1</code> ) of the decompress function and store that in a variable called <code>FILETYPE</code>. We will then create a nice <code>echo</code> to give some info about the current file type being matched to.</p>
<pre tabindex=0><code># function to match filetypes to correct command
function decompress () {
        FILETYPE=$(get_file_type $1)
        echo &quot;[+] $1 matched to $FILETYPE filetype&quot;
}
</code></pre><p>Now lets create some <code>if-statements</code>. We know that there are 4 possible file types <code>gzip</code> <code>bzip2</code> <code>tar</code> and probally <code>ASCII</code> once we hit the password file. Lets checks for each filetype and and finaly <code>else</code> as a catch in the case that we hit an unknown file type. (We also add a sleep in there, just in case something weird happens in our code logic.)</p>
<pre tabindex=0><code># function to match filetypes to correct command
function decompress () {
        FILETYPE=$(get_file_type $1)
        echo &quot;[+] $1 matched to $FILETYPE filetype&quot;
        if [ &quot;$FILETYPE&quot; = &quot;gzip&quot; ]; then
                #
        elif [ &quot;$FILETYPE&quot; = &quot;bzip2&quot; ]; then
                #E
        elif [ &quot;$FILETYPE&quot; = &quot;POSIX&quot; ]; then
                #
        elif [ &quot;$FILETYPE&quot; = &quot;ASCII&quot; ]; then
                #
        else
                echo &quot;$FILETYPE is unknown&quot;
        fi
        sleep 1
}
</code></pre><p>Now that we have our <code>if-statements</code> its a simple case of using the right command to decompress the filetype, but before we do that lets create another <code>if-statement</code> and variable called <code>FILENAME</code>.</p>
<p>Our decompression commands need a filename to decompress to. We want to store this filename in a variable so we know what we should check in the next instance on the loop. We could create a function that checks for newly created files, but this is way easier imo.</p>
<p>However, we don&rsquo;t want to overwrite the value in <code>FILENAME</code> once we hit the <code>ASCII</code> file type. In this case we simply want to keep <code>FILENAME</code> set to the same value of the previous loop. We then simply call <code>cat</code> the using the <code>FILENAME</code> variable. To check for this we can do a <code>does not equal</code> check on <code>ASCCI</code> (<code>!=</code>).</p>
<p>To generate a random filename we use <code>$RANDOM</code>. <code>$RANDOM</code> is an internal Bash function that returns integer in the range 0 - 32767. There is a slight chance that we get a duplicate file name, but lets risk it.</p>
<p><code>zcat</code> and <code>bzcat</code> both work nicely with redirection the output to <code>$FILENAME</code>. <code>tar</code> how ever does not. To still store the <code>FILENAME</code> we simply store the output of <code>tar</code> in <code>FILENAME</code> like this <code>FILENAME=$(tar xvf $1)</code> .</p>
<p>Our <code>decompress</code> function now looks like this. Now that we have that setup we can focus on the loop.</p>
<pre tabindex=0><code># function to match filetypes to correct command
function decompress () {
        FILETYPE=$(get_file_type $1)
        if [ &quot;$FILETYPE&quot; != &quot;ASCII&quot; ]; then
                FILENAME=&quot;out_$RANDOM&quot;
        fi
        echo &quot;[+] $1 matched to $FILETYPE filetype&quot;
        if [ &quot;$FILETYPE&quot; = &quot;gzip&quot; ]; then
                zcat $1 &gt; $FILENAME
        elif [ &quot;$FILETYPE&quot; = &quot;bzip2&quot; ]; then
                bzcat $1 &gt; $FILENAME
        elif [ &quot;$FILETYPE&quot; = &quot;POSIX&quot; ]; then
                FILENAME=$(tar xvf $1)
        elif [ &quot;$FILETYPE&quot; = &quot;ASCII&quot; ]; then
                cat $FILENAME
        else
                echo &quot;$FILETYPE is unknown&quot;
        fi
        sleep 1
}
</code></pre><p>We setup a variable called <code>LOOP</code> with the value of <code>1</code>. We then create a <code>until</code> loop and tell it to run as long <code>LOOP</code> does not have the value of <code>0</code>. Then we call our <code>decompress</code> function.</p>
<pre tabindex=0><code>LOOP=1
until [ $LOOP = 0 ]
do
        decompress $FILENAME
done
</code></pre><p>To stop the <code>until</code> loop once we hit the <code>ASCII</code> file type we update our <code>decompress</code> function. Once the <code>FILETYPE</code> matches <code>ASCII</code> and after we used <code>cat</code> to output the file we set the <code>LOOP</code> variable to <code>0</code>.</p>
<pre tabindex=0><code># function to match filetypes to correct command
function decompress () {
        FILETYPE=$(get_file_type $1)
        if [ &quot;$FILETYPE&quot; != &quot;ASCII&quot; ]; then
                FILENAME=&quot;out_$RANDOM&quot;
        fi
        echo &quot;[+] $1 matched to $FILETYPE filetype&quot;
        if [ &quot;$FILETYPE&quot; = &quot;gzip&quot; ]; then
                zcat $1 &gt; $FILENAME
        elif [ &quot;$FILETYPE&quot; = &quot;bzip2&quot; ]; then
                bzcat $1 &gt; $FILENAME
        elif [ &quot;$FILETYPE&quot; = &quot;POSIX&quot; ]; then
                FILENAME=$(tar xvf $1)
        elif [ &quot;$FILETYPE&quot; = &quot;ASCII&quot; ]; then
                cat $FILENAME
                LOOP=0
        else
                echo &quot;$FILETYPE is unknown&quot;
        fi
        sleep 1
}
</code></pre><p>The only thing left to do is to set the first instance <code>FILENAME</code> so the <code>decompress</code> function knows where to start, so lets just do that with <code>read</code> so we can supply this on the commandline.</p>
<pre tabindex=0><code>echo &quot;[?] What file should we decompress? &quot;
read FILENAME
LOOP=1
until [ $LOOP = 0 ]
do
        decompress $FILENAME
done
</code></pre><p>Here is our final script.</p>
<pre tabindex=0><code>#bin/bash
# function to get filetype using file and cut
function get_file_type () {
        file $1 | cut -d &quot; &quot; -f 2
}
# function to match filetypes to correct command
function decompress () {
        FILETYPE=$(get_file_type $1)
        echo &quot;[+] $1 matched to $FILETYPE filetype&quot;
        if [ &quot;$FILETYPE&quot; != &quot;ASCII&quot; ]; then
                FILENAME=&quot;out_$RANDOM&quot;
        fi
        if [ &quot;$FILETYPE&quot; = &quot;gzip&quot; ]; then
                zcat $1 &gt; $FILENAME
        elif [ &quot;$FILETYPE&quot; = &quot;bzip2&quot; ]; then
                bzcat $1 &gt; $FILENAME
        elif [ &quot;$FILETYPE&quot; = &quot;POSIX&quot; ]; then
                FILENAME=$(tar xvf $1)
        elif [ &quot;$FILETYPE&quot; = &quot;ASCII&quot; ]; then
                cat $FILENAME
                LOOP=0
        else
                echo &quot;$FILETYPE is unknown&quot;
        fi
        sleep 1
}
echo &quot;[?] What file should we decompress? &quot;
read FILENAME
LOOP=1
until [ $LOOP = 0 ]
do
        decompress $FILENAME
done
</code></pre><p>And here it is in action 🔮</p>
<pre tabindex=0><code>bandit12@bandit/tmp/esc$ ./unpackhex.sh
[?] What file should we decompress?
reversed.hex
[+] reversed.hex matched to gzip filetype
[+] out_21267 matched to bzip2 filetype
[+] out_14023 matched to gzip filetype
[+] out_30556 matched to POSIX filetype
[+] data5.bin matched to POSIX filetype
[+] data6.bin matched to bzip2 filetype
[+] out_30902 matched to POSIX filetype
[+] data8.bin matched to gzip filetype
[+] out_14824 matched to ASCII filetype
The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL
bandit12@bandit/tmp/esc$ logout
Connection to bandit.labs.overthewire.org closed.
</code></pre>
</article>
<div class=pagination>
<a href=https://justin-p.me/blog/write-up-overthewire-bandit-level-7-level-12/>&#171; Write-up: OverTheWire - Bandit Level 7 → Level 12</a>
<a href=https://justin-p.me/blog/write-up-overthewire-bandit-level-13-level-16/>Write-up: OverTheWire - Bandit Level 13 → Level 16 &#187;</a>
</div>
</section>
<br>
<section class=disqus>
<div id=disqus_thread></div>
<script type=text/javascript>(function(){var b,a;if(window.location.hostname=="localhost")return;b='',a=document.createElement('script'),a.type='text/javascript',a.async=!0,a.src='//'+b+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view comments powered by <a href=http://disqus.com/?ref_noscript>Disqus</a>.</noscript>
</section>
</section>
</main>
<footer class="row middle-xs center-xs">
<div class="col-xs-3 col-md-2"><a target=_blank rel=noopener href=https://github.com/justin-p>GitHub</a></div>
<div class="col-xs-3 col-md-2"><a target=_blank rel=noopener href=https://linkedin.com/in/justinperdok>LinkedIn</a></div>
<div class="col-xs-3 col-md-2"><a target=_blank rel=noopener href=https://twitter.com/JustinPerdok>Twitter</a></div>
</footer>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script>
<script src=https://justin-p.me/js/src/main.min.eae71e379c2461af7fb34269ff746c36d0aa5343dd34e47314df0f3808c2d2a1.js type=text/javascript></script>
</body>
</html>